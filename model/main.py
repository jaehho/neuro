"""
LIF neuron with reward-modulated STDP (single synapse).

Simulates a leaky integrate-and-fire (LIF) postsynaptic neuron driven by a
single presynaptic spike train. Synaptic plasticity is implemented as a
reward-modulated eligibility-trace rule with pre/post traces and bounded,
weight-dependent update scaling.

Notes
-----
- Time is advanced with forward Euler using ``dt`` (ms).
- Presynaptic spikes are generated by a Bernoulli approximation to a
  Poisson process (per-step probability = firing_rate * dt).
- Voltage is set to 0 at spike times only for visualization.
"""

import os
import numpy as np
import matplotlib.pyplot as plt

save_path = os.path.join(
    os.path.dirname(__file__),
    "../data/interim/simulation_results.png",
)

# Parameters
dt = 0.1          # ms
T_total = 2000.0  # ms
time = np.arange(0, T_total, dt)
n_steps = len(time)

# LIF parameters (ms, mV, MOhm)
tau_m = 20.0
E_L = -70.0
V_reset = -70.0
V_thresh = -54.0
R_m = 50.0
tau_ref = 5.0

# Synapse
tau_s = 5.0

# Plasticity traces (ms)
tau_plus = 20.0
tau_minus = 20.0
tau_e = 100.0

# Weight rule
w_max = 2.0
w_init = 0.5
eta_plus = 0.05
eta_minus = 0.05

# Inputs
np.random.seed(0)
pre_firing_rate = 0.02  # spikes/ms
pre_spikes = np.random.rand(n_steps) < (pre_firing_rate * dt)

reward_signal = np.zeros(n_steps)
pulse_period_steps = int(500 / dt)
pulse_width_steps = int(100 / dt)
for i in range(0, n_steps, pulse_period_steps):
    reward_signal[i:i + pulse_width_steps] = 0.1

baseline_reward = 0.01
M = reward_signal - baseline_reward

# State
v_post = np.ones(n_steps) * E_L
i_syn = np.zeros(n_steps)
w = np.zeros(n_steps)
w[0] = w_init

x_trace = np.zeros(n_steps)
y_trace = np.zeros(n_steps)
e_trace = np.zeros(n_steps)
post_spikes = np.zeros(n_steps, dtype=bool)

ref_counter = 0

# Simulation
for t in range(1, n_steps):

    # Trace decay (Euler): dx/dt = -x/tau.
    x_trace[t] = x_trace[t - 1] + dt * (-x_trace[t - 1] / tau_plus)
    y_trace[t] = y_trace[t - 1] + dt * (-y_trace[t - 1] / tau_minus)

    # Apply synaptic kick at spike arrival time for the current weight.
    if pre_spikes[t - 1]:
        x_trace[t] += 1.0
        i_syn[t - 1] += w[t - 1]

    i_syn[t] = i_syn[t - 1] + dt * (-i_syn[t - 1] / tau_s)

    if ref_counter > 0:
        v_post[t] = V_reset
        ref_counter -= 1
    else:
        dv = (-(v_post[t - 1] - E_L) + R_m * i_syn[t]) / tau_m
        v_post[t] = v_post[t - 1] + dt * dv

        if v_post[t] >= V_thresh:
            v_post[t] = 0.0  # Visual marker only.
            post_spikes[t] = True
            ref_counter = int(tau_ref / dt)
            y_trace[t] += 1.0

    # Weight-dependent scaling bounds updates near 0 and w_max.
    A_plus = eta_plus * (w_max - w[t - 1])
    A_minus = eta_minus * w[t - 1]

    S_ij = 0.0
    if post_spikes[t]:
        S_ij += A_plus * x_trace[t]
    if pre_spikes[t]:
        S_ij -= A_minus * y_trace[t]

    # Convert impulse-like pairing term into a per-step contribution.
    de = (-e_trace[t - 1] / tau_e) + (S_ij / dt)
    e_trace[t] = e_trace[t - 1] + dt * de

    w[t] = w[t - 1] + dt * (M[t] * e_trace[t])
    w[t] = np.clip(w[t], 0.0, w_max)

# Plotting
fig, axs = plt.subplots(4, 1, figsize=(10, 12), sharex=True)

axs[0].set_title("Neural Activity (Pre & Post)")
axs[0].plot(time, v_post, label=r"Post $V_m$ (mV)", linewidth=1, color="blue")
axs[0].axhline(V_thresh, linestyle="--", label=r"Threshold $\vartheta$")
pre_spike_times = time[pre_spikes]
axs[0].scatter(
    pre_spike_times,
    np.ones_like(pre_spike_times) * E_L - 1,
    marker="|",
    s=50,
    label=r"Pre spikes $\rho_j$",
    color="red",
)
axs[0].legend(loc="upper right")
axs[0].set_ylabel("Voltage (mV)")
axs[0].set_ylim(-72, -50)

axs[1].set_title("Synaptic Traces")
axs[1].plot(time, x_trace, label=r"Pre trace $x_j(t)$", color="red")
axs[1].plot(time, y_trace, label=r"Post trace $y_i(t)$", color="blue")
axs[1].legend(loc="upper right")
axs[1].set_ylabel("Trace magnitude")

axs[2].set_title("Eligibility Trace & Reward Signal")
axs[2].plot(time, e_trace, label=r"Eligibility $E_{ij}(t)$")
axs[2].plot(time, M, label=r"Neuromodulation $M(t)$", linestyle="--",
            alpha=0.5)
axs[2].legend(loc="upper right")
axs[2].set_ylabel("Magnitude")

axs[3].set_title("Synaptic Weight Evolution")
axs[3].plot(time, w, label=r"Weight $w_{ij}$", color="black")
axs[3].set_ylim(0, w_max)
axs[3].set_ylabel("Weight")
axs[3].set_xlabel("Time (ms)")
axs[3].legend()

plt.tight_layout()
plt.savefig(save_path)
